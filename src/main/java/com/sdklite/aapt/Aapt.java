package com.sdklite.aapt;

import static com.sdklite.aapt.Internal.*;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * The AAPT Utility
 */
public class Aapt {

    public static final String RESOURCES_ARSC = "resources.arsc";

    public static final String ANDROID_MANIFEST_XML = "AndroidManifest.xml";

    /**
     * Generate R.java
     * 
     * @param os
     *            The output stream
     * @param pkg
     *            The package name
     * @param symbols
     *            The resource symbols
     * @throws IOException
     */
    public static void generateR(final OutputStream os, final String pkg, final Symbols symbols) throws IOException {
        final Map<String, List<Symbols.Entry>> types = new TreeMap<String, List<Symbols.Entry>>();
        for (final Symbols.Entry entry : symbols.entries.values()) {
            final List<Symbols.Entry> entries = types.containsKey(entry.type.name) ? types.get(entry.type.name) : new ArrayList<Symbols.Entry>();
            entries.add(entry);
            types.put(entry.type.name, entries);
        }

        final PrintWriter out = new PrintWriter(os, true);
        out.printf("/* AUTO-GENERATED FILE.  DO NOT MODIFY.").println();
        out.printf(" *").println();
        out.printf(" * This class was automatically generated by the").println();
        out.printf(" * aapt tool from the resource data it found.  It").println();
        out.printf(" * should not be modified by hand.").println();
        out.printf(" */").println();
        out.printf("package %s;\r\n", pkg).println();
        out.printf("public final class R {").println();

        for (final Map.Entry<String, List<Symbols.Entry>> pair : types.entrySet()) {
            out.printf("    public static final class %s {", pair.getKey()).println();

            for (final Symbols.Entry entry : pair.getValue()) {
                if (entry instanceof Symbols.Styleable) {
                    out.printf("        public static final %s %s = { ", entry.vtype, entry.name);

                    final Symbols.Styleable styleable = (Symbols.Styleable) entry;
                    for (int i = 0, n = styleable.values.size(); i < n; i++) {
                        if (i > 0) {
                            out.print(", ");
                        }

                        out.printf("0x%08x", styleable.values.get(i));
                    }

                    out.printf(" };").println();
                } else {
                    out.printf("        public static final %s %s = 0x%08x;", entry.vtype, entry.name, entry.value).println();
                }
            }

            out.printf("    }").println();
        }

        out.printf("}").println();
        out.flush();
    }

    /**
     * Generate R.java
     * 
     * @param r
     *            The R.java file
     * @param pkg
     *            The package name
     * @param symbols
     *            The resource symbols
     * @throws IOException
     */
    public static void generateR(final File r, final String pkg, final Symbols symbols) throws IOException {
        if (!r.getParentFile().exists()) {
            r.getParentFile().mkdirs();
        }

        if (!r.exists()) {
            r.createNewFile();
        }

        final FileOutputStream out = new FileOutputStream(r);

        try {
            generateR(out, pkg, symbols);
        } finally {
            out.close();
        }
    }

    /**
     * Generate R.java
     * 
     * @param r
     *            The R.java file
     * @param pkg
     *            The package name
     * @param symbols
     *            The resource symbols
     * @throws IOException
     */
    public static void generateR(final String r, final String pkg, final Symbols symbols) throws IOException {
        generateR(new File(r), pkg, symbols);
    }

    public static final void main(final String[] args) throws IOException {
        if (args.length < 1) {
            printUsage();
            return;
        }

        final String cmd = args[0];
        if ("dump".equals(cmd) || "d".equals(cmd)) {
            if (args.length < 3) {
                printUsage();
                return;
            }

            final String type = args[1];
            final ChunkParser parser = new ChunkParser(args[2]);
            final Visitor visitor;

            if ("resources".equals(type)) {
                visitor = new ResourcesVisitor(System.out, true);
            } else if ("strings".equals(type)) {
                visitor = new StringsVisitor(System.out, true);
            } else if ("xml".equals(type)) {
                visitor = new XmlVisitor(System.out, true);
            } else {
                visitor = new SimpleVisitor();
            }

            parser.parse().accept(visitor);
        } else if ("help".equals(cmd) || "h".equals(cmd) || "?".equals(cmd)) {
            printUsage();
        } else {
            printUsage();
        }
    }

    private final File assetDir;

    private final Revision buildToolRevision;

    public Aapt(final File assetDir, final String buildToolRevision) {
        this(assetDir, Revision.parseRevision(buildToolRevision));
    }

    public Aapt(final File assetDir, final Revision buildToolRevision) {
        this.assetDir = assetDir;
        this.buildToolRevision = buildToolRevision;
    }

    public File getAssetDirectory() {
        return assetDir;
    }

    public Revision getBuildToolRevision() {
        return buildToolRevision;
    }

    /**
     * Delete the resource files related to the specified symbols
     * 
     * @param symbols
     *            The resource symbols
     * @return deleted resource keys
     */
    public Set<String> deleteResources(final Symbols symbols) {
        final Set<String> resources = new HashSet<String>();
        final File resDir = new File(this.assetDir, "res");
        final File[] typeDirs = resDir.listFiles();

        if (null != typeDirs) {
            for (final File typeDir : typeDirs) {
                final File[] entryFiles = typeDir.listFiles();
                if (null == entryFiles || entryFiles.length <= 0) {
                    typeDir.delete();
                    continue;
                }

                final Symbols.Entry entry = find(symbols.entries.values(), new Filter<Symbols.Entry>() {
                    @Override
                    public boolean accept(final Symbols.Entry it) {
                        return typeDir.getName().startsWith(it.type.name);
                    }
                });

                if (null == entry) {
                    for (final File entryFile : entryFiles) {
                        resources.add(String.format("res%s%s%s%s", File.separator, typeDir.getName(), File.separator, entryFile.getName()));
                        entryFile.delete();
                    }
                } else {
                    for (final File entryFile : entryFiles) {
                        final Symbols.Entry resEntry = find(symbols.entries.values(), new Filter<Symbols.Entry>() {
                            @Override
                            public boolean accept(final Symbols.Entry it) {
                                return entryFile.getName().startsWith(it.name + ".");
                            }
                        });

                        if (null != resEntry) {
                            resources.add(String.format("res%s%s%s%s", File.separator, typeDir.getName(), File.separator, entryFile.getName()));
                        }

                        entryFile.delete();
                    }
                }

                typeDir.delete(); // it shall be succeeded if it's empty
            }
        }

        return resources;
    }

    private static void printUsage() {
        System.out.println("Usage: aapt <command> [args]");
        System.out.println();
        System.out.println("  Commands:");
        System.out.println("    - dump [resources, strings, xml]             Dump asset chunks");
        System.out.println();
    }
}
